\section{La carte de données \texttt{PairMap}}

La structure de données dans laquelle on stocke les caractères est un dictionnaire qui a pour clef l'\textsc{ids} d'un caractère (ou son hash). Il faut une structure qui évite complètement les redondances, c'est-à-dire que la forêt des sinogrammes n'ait pas de doublon quel que soit l'ordre dans lequel les caractères sont entrés et quel que soit le détail des \textsc{ids}. \texttt{PairMap} n'a pas vocation a être générique : des structures existent déjà pour cela mais à offrir la solution la plus adaptée au stockage des sinogrammes.

Trois stratégies d'optimisation des accès mémoires :
\begin{itemize}
\item Un tas ;
\item Un accès aléatoire ;
\item Un arbre couvrant.
\end{itemize}

\paragraph{Stratégie du tas}
\begin{itemize}
\item Chaque caractère possède ses propres composants ;
\item La taille d'un tas est 3 ;
\item Solution tributaire des \textsc{ids} ;
\item Explosion combinatoire pour mettre à jour ;
\item Analyse de caractère rapide.
\end{itemize}

\paragraph{Stratégie de l'accès aléatoire}
\begin{itemize}
\item Lecture et écriture rapide si vraiment aléatoire ;
\item Chaque sinogramme contient un tableau de référence de composants.
\end{itemize}

\paragraph{Stratégie de l'arbre couvrant}
\begin{itemize}
\item Hypothèse : faiblement connecté ;
\item Euh\dots{} mais ce n'est vraiment pratique à parcourir !
\end{itemize}

Un sinogramme comporte trois références vers ses composants et pour l'immense majeure partie deux références. Si le sinogramme est une entrée de la table on a un caractère, un point de code et une \textsc{ids}. Si c'est un sinogramme induit on n'a qu'une \textsc{ids}. Certains sinogrammes d'un pan Unicode (\textsl{unicode block}) sont décomposés en sinogrammes qui n'ont pas de décomposition dans ce pan mais se décomposent dans un autre pan. L'ordre de décomposition des sinogrammes n'est pas respecté globalement mais seulement à l'intérieur d'un pan. Bien qu'un point de code et une \textsc{ids} renvoient à une même réalité, il faut les voir comme deux sous-clefs, facette d'une même clef.

Tous les caractères ont une \textsc{ids} mais seulement les caractères explicites ont un point de code. Les caractères implicites n'ont pas de point de code, seulement une \textsc{ids}. L'\textsc{ids} peut donc être vue comme une clef principale à côté de laquelle on place lorsque c'est possible un point de code. L'organisation interne de \texttt{PairMap} devra donc être un dictionnaire \texttt{(K1, V)} avec \texttt{K1} une \textsc{ids} et \texttt{V} une référence vers un objet \texttt{Node}. Il y a également un dictionnaire \texttt{(K2, K1)} avec \texttt{K2} un point de code. Le dictionnaire réciproque \texttt{(K1, K2)} n'est nécessaire que pour économiser la résolution d'une référence : on peut en effet accéder à \texttt{K2} très facilement à partir de \texttt{K1} : \texttt{K1} → \texttt{V.K2}.

L'interface de \texttt{PairMap} est finalement un dictionnaire \texttt{(K1, K2, V)}.

La classe \href{http://download.java.net/jdk8u20/docs/api/java/util/TreeMap.html}{\texttt{TreeMap}} peut-elle apporter quelque chose de plus que \texttt{HashMap} ?
