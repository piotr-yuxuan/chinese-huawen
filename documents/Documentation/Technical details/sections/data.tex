Analyser un fichier et construire une représentation abstraite de l'information qu'il contient à partir des informations que l'on en obtient ligne par ligne est un problème d'analyse syntaxique\footnote{Un analyseur syntaxique est un \textsl{parser} en anglais.} dont il faut ensuite enregistrer les résultats pour pouvoir les utiliser plus tard. Plusieurs solutions sont envisagées dans le cadre de ce micro-projet. 

\section{Analyse syntaxique d'un fichier texte}

Programmation impérative ou tentative de programmation fonctionnelle.

\section{Stockage des données}

L'idée la plus naturelle est d'obtenir en sortie du programme deux fichiers textes qui contiennent une liste de nœuds et une liste d'arêtes mais cette idée mène très rapidement à utiliser une représentation temporaire de la structure de composition des sinogrammes. On peut donc également construire une représentation temporaire des objets, l'afficher puis éteindre le programme sans en garder trace. Il est enfin envisageable d'enregistrer le résultat obtenu dans une base de données pour faciliter son exploitation ultérieure.

Nous avons bénéficié des lumières de Messieurs \textsc{Robert} et \textsc{Talel}, professeurs respectivement d'architecture des ordinateurs et de bases de données que nous remercions, pour explorer ces trois voies : représentation temporaire, génération de listes et utilisation de base de données. Ces trois voies posent chacune des questions intéressantes en optimisation et modèle relationnel.

Plusieurs choix s'offrent à nous pour le stockage des sinogrammes. La solution la plus pérenne est de passer par une base de données et donc d'utiliser le disque dur. Cela pose des contraintes de , mais quelle est la solution la plus rapide ? 
Tous les caractères ont une \textsc{ids} mais seulement les caractères explicites ont un point de code.

\subsection{Listes d'arêtes et de nœuds}

\subsection{Base de données Maria\textsc{db}}

\paragraph{Notule} Je remercie M. \textsc{Talel}, qui donne le cours \texttt{inf225}, de bien avoir accepté de répondre à mes questions.

\subsection{La carte de données \texttt{PairMap}}

\paragraph{Notule} Je remercie M. \textsc{Robert}, qui donne le cours \texttt{inf227}, de bien avoir accepté de répondre à mes questions.

\subsubsection{Statégies d'optimisation}

La structure de données dans laquelle on stocke les caractères est un dictionnaire qui a pour clef l'\textsc{ids} d'un caractère (ou son hash). Il faut une structure qui évite complètement les redondances, c'est-à-dire que la forêt des sinogrammes n'ait pas de doublon quel que soit l'ordre dans lequel les caractères sont entrés et quel que soit le détail des \textsc{ids}. \texttt{PairMap} n'a pas vocation a être générique : des structures existent déjà pour cela mais à offrir la solution la plus adaptée au stockage des sinogrammes.

Trois stratégies d'optimisation des accès mémoires :
\begin{itemize}
\item Un tas ;
\item Un accès aléatoire ;
\item Un arbre couvrant.
\end{itemize}

\paragraph{Stratégie du tas}
\begin{itemize}
\item Chaque caractère possède ses propres composants ;
\item La taille d'un tas est 3 ;
\item Solution tributaire des \textsc{ids} ;
\item Explosion combinatoire pour mettre à jour ;
\item Analyse de caractère rapide.
\end{itemize}

\paragraph{Stratégie de l'accès aléatoire}
\begin{itemize}
\item Lecture et écriture rapide si vraiment aléatoire ;
\item Chaque sinogramme contient un tableau de référence de composants.
\end{itemize}

\paragraph{Stratégie de l'arbre couvrant}
\begin{itemize}
\item Hypothèse : faiblement connecté ;
\item Euh\dots{} mais ce n'est vraiment pratique à parcourir !
\end{itemize}

Un sinogramme comporte trois références vers ses composants et pour l'immense majeure partie deux références. Si le sinogramme est une entrée de la table on a un caractère, un point de code et une \textsc{ids}. Si c'est un sinogramme induit on n'a qu'une \textsc{ids}. Certains sinogrammes d'un pan Unicode (\textsl{unicode block}) sont décomposés en sinogrammes qui n'ont pas de décomposition dans ce pan mais se décomposent dans un autre pan. L'ordre de décomposition des sinogrammes n'est pas respecté globalement mais seulement à l'intérieur d'un pan. Bien qu'un point de code et une \textsc{ids} renvoient à une même réalité, il faut les voir comme deux sous-clefs, facette d'une même clef.

Tous les caractères ont une \textsc{ids} mais seulement les caractères explicites ont un point de code. Les caractères implicites n'ont pas de point de code, seulement une \textsc{ids}. L'\textsc{ids} peut donc être vue comme une clef principale à côté de laquelle on place lorsque c'est possible un point de code. L'organisation interne de \texttt{PairMap} devra donc être un dictionnaire \texttt{(K1, V)} avec \texttt{K1} une \textsc{ids} et \texttt{V} une référence vers un objet \texttt{Node}. Il y a également un dictionnaire \texttt{(K2, K1)} avec \texttt{K2} un point de code. Le dictionnaire réciproque \texttt{(K1, K2)} n'est nécessaire que pour économiser la résolution d'une référence : on peut en effet accéder à \texttt{K2} très facilement à partir de \texttt{K1} : \texttt{K1} → \texttt{V.K2}.

L'interface de \texttt{PairMap} est finalement un dictionnaire \texttt{(K1, K2, V)}.

La classe \href{http://download.java.net/jdk8u20/docs/api/java/util/TreeMap.html}{\texttt{TreeMap}} peut-elle apporter quelque chose de plus que \texttt{HashMap} ?